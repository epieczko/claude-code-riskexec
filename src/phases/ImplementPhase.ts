import { invokeAgent } from '../lib/invokeAgent';
import { writeFileAtomic } from '../lib/files';
import { mirrorAgentOsDirectory } from '../lib/agentOs';
import { loadContext } from '../lib/contextStore';
import type { TaskContext } from '../lib/contextStore';
import { PhaseHandler, PhaseResult, PhaseRunOptions } from './types';
import {
  assertPhasePrerequisites,
  ensureFeaturePaths,
  readPhaseFiles,
  resolveFeaturePaths
} from '../lib/phaseUtils';
import path from 'path';
import { createPhaseLogger } from '../lib/logger';
import { parseTasksChecklist, parseTasksFromContext, slugifyTaskTitle, TaskItem } from '../lib/tasks';

/**
 * Executes implementation tasks generated by previous phases. The phase ensures
 * prerequisite artifacts exist, iterates over each checklist item in `tasks.md`
 * (or stored task context), and records implementation notes per task under the
 * `implementation/` directory. Outputs are mirrored to Agent OS for review.
 */
export class ImplementPhase implements PhaseHandler {
  public readonly phaseName = 'implement';

  public async run(options: PhaseRunOptions): Promise<PhaseResult> {
    const logger = createPhaseLogger(this.phaseName);
    const paths = resolveFeaturePaths(options.featureDir);
    await ensureFeaturePaths(paths, [paths.implementationDir]);

    const io = await readPhaseFiles([
      { key: 'spec', path: paths.spec, description: 'Specification', required: true },
      { key: 'plan', path: paths.plan, description: 'Implementation plan', required: true },
      { key: 'tasks', path: paths.tasks, description: 'Task list', required: true }
    ]);

    assertPhasePrerequisites(io, this.phaseName);

    const tasksMarkdown = io.files.tasks as string;

    const storedTaskContext: TaskContext | null =
      options.taskContext ??
      (await loadContext<TaskContext>(options.featureName, 'tasks', { workspaceRoot: options.workspaceRoot }));

    const tasks: TaskItem[] = storedTaskContext
      ? parseTasksFromContext(storedTaskContext)
      : parseTasksChecklist(tasksMarkdown);
    if (!tasks.length) {
      throw new Error('No tasks found in tasks.md. Ensure the file contains checklist items.');
    }

    let startIndex = 0;
    if (options.resumeFromTask) {
      const resumeIndex = tasks.findIndex(task => task.title.includes(options.resumeFromTask as string));
      if (resumeIndex === -1) {
        throw new Error(`Unable to locate task containing "${options.resumeFromTask}".`);
      }
      startIndex = resumeIndex;
    }

    const logPaths: string[] = [];
    for (let i = startIndex; i < tasks.length; i += 1) {
      const task = tasks[i];
      const prompt = [
        `Execute the implementation work for task ${task.index}: ${task.title}.`,
        'Provide code changes, testing steps, and QA notes.',
        'Summarize validation evidence and next actions.'
      ].join('\n\n');

      const contextFiles = [
        { path: paths.spec, label: 'Specification', optional: false },
        { path: paths.plan, label: 'Implementation Plan', optional: false },
        { path: paths.tasks, label: 'Task List', optional: false }
      ];

      const result = await invokeAgent({
        agent: 'bmad-developer',
        featureName: options.featureName,
        workspaceRoot: options.workspaceRoot,
        prompt,
        contextFiles,
        metadata: {
          phase: this.phaseName,
          taskLabel: task.title,
          taskIndex: String(task.index),
          taskTotal: String(tasks.length),
          taskSource: storedTaskContext ? 'context-store' : 'markdown'
        }
      });

      const filename = `task-${task.index}-${slugifyTaskTitle(task.title) || 'implementation'}.md`;
      const outputPath = path.join(paths.implementationDir, filename);
      await writeFileAtomic(outputPath, `${result.outputText.trim()}\n`);
      logPaths.push(outputPath);
      logger.info(`Task ${task.index}/${tasks.length} complete â†’ ${path.basename(outputPath)}`);
    }

    await mirrorAgentOsDirectory({
      workspaceRoot: options.workspaceRoot,
      featureName: options.featureName,
      sourceDir: paths.implementationDir,
      targetSubdir: path.relative(options.featureDir, paths.implementationDir)
    });

    return {
      phase: this.phaseName,
      outputPath: paths.implementationDir,
      logPaths,
      details: {
        tasksExecuted: logPaths.length,
        tasksFromContext: Boolean(storedTaskContext)
      }
    };
  }
}

export default ImplementPhase;
